/* ************************************************************************** *//*                                                                            *//*                                                        :::      ::::::::   *//*   algo.c                                             :+:      :+:    :+:   *//*                                                    +:+ +:+         +:+     *//*   By: agermain <marvin@42.fr>                    +#+  +:+       +#+        *//*                                                +#+#+#+#+#+   +#+           *//*   Created: 2017/01/07 18:20:29 by agermain          #+#    #+#             *//*   Updated: 2017/01/15 19:00:57 by agermain         ###   ########.fr       *//*                                                                            *//* ************************************************************************** */#include "fillit.h"#define offset(x) [((x) / 8)]static inline t_ushort get_offset(t_bmask a){	t_ushort i;	i = 0;	while (!((a << i) & 0b10000000))		i++;	return (i);}static inline t_ushort get_last_offset(t_bmask a){	t_ushort i;	i = 0;	while (!((a >> i) & 0b00000001))		i++;	return (8 - i);}static inline t_ushort min(unsigned short a, unsigned short b){	return (a < b ? a : b);}static inline t_ushort max(unsigned short a, unsigned short b){	return (a > b ? a : b);}static t_ushort	*board_size(t_board_cst board){	t_ushort x;	t_ushort y;	t_ushort *ret;	ret = malloc(3 * sizeof(t_ushort *));	ret[0] = 0;	ret[1] = 0;	y = 0;	while (y < board->size)	{		x = 0;		while (x < board->size)		{			if (board->board[y][x] != '.')			{				ret[1] = max(ret[1], y + 1);				ret[0] = max(ret[0], x + 1);			}			x++;		}		y++;	}	ret[2] = max(ret[0], ret[1]);	return (ret);}static short int	can_place_line(t_ushort line, t_bmask *boardline, unsigned short x){	t_ushort	board_cells;	board_cells = *((t_ushort *)(&(((boardline))offset(x))));	return (board_cells & line ? 0 : 1);}static t_board *place_piece(t_ushort piece, t_board_cst board, unsigned short x, unsigned short y, unsigned short piece_idx){	t_board			*stepboard;	t_ushort	piece_l[4];	t_ushort	*piece_size;	t_ushort	line;	t_ushort	bit_offset;	piece_size = get_piece_size(piece);	if (((x + piece_size[0]) > board->size) || ((y + piece_size[1]) > board->size))		return (NULL);	free(piece_size);	bit_offset = x % 8;	piece_l[0] = (((t_ushort)(piece & 0xF000)) << 0)  >> bit_offset;	piece_l[1] = (((t_ushort)(piece & 0x0F00)) << 4)  >> bit_offset;	piece_l[2] = (((t_ushort)(piece & 0x00F0)) << 8)  >> bit_offset;	piece_l[3] = (((t_ushort)(piece & 0x000F)) << 12) >> bit_offset;	if(!((can_place_line(piece_l[0], board->bit_mask[y], x)) &&	   (!piece_l[1] || (y + 1 < board->size && can_place_line(piece_l[1], board->bit_mask[y + 1], x))) &&	   (!piece_l[2] || (y + 2 < board->size && can_place_line(piece_l[2], board->bit_mask[y + 2], x))) &&	   (!piece_l[3] || (y + 3 < board->size && can_place_line(piece_l[3], board->bit_mask[y + 3], x)))))        return (NULL);    stepboard = duplicate_board(board);	line = 0;	while (line < 4 && y + line < board->size)	{		if(x + 0 < board->size && (piece_l[line] << bit_offset) & 0x8000)			stepboard->board[y + line][x + 0] = (char)'A' + piece_idx;		if(x + 1 < board->size && (piece_l[line] << bit_offset) & 0x4000)			stepboard->board[y + line][x + 1] = (char)'A' + piece_idx;		if(x + 2 < board->size && (piece_l[line] << bit_offset) & 0x2000)			stepboard->board[y + line][x + 2] = (char)'A' + piece_idx;		if(x + 3 < board->size && (piece_l[line] << bit_offset) & 0x1000)			stepboard->board[y + line][x + 3] = (char)'A' + piece_idx;		t_ushort *bit_mask = &((((t_bmask*)stepboard->bit_mask[y + line]))offset(x));		(*bit_mask) |= piece_l[line];		line++;	}	stepboard->area = board_size(stepboard);	return (stepboard);}static t_board *get_best_board(t_board *candidate_board, t_board *best_board){	t_ushort	*candidate_size;	t_ushort	*best_size;	if (candidate_board == NULL)		return (best_board);	if (best_board == NULL)		return (candidate_board);	candidate_size = candidate_board->area;	best_size = best_board->area;	if (candidate_size[2] >= best_size[2])		return (best_board);	else		return (candidate_board);}static t_board	*choose_best_board(t_board *candidate_board, t_board *best_board){	t_board *board;	board = get_best_board(candidate_board, best_board);	if (board == candidate_board)	{		if (best_board != NULL)			free_board(best_board);	}	else	{		if (candidate_board != NULL)			free_board(candidate_board);	}	return (board);}static  t_board	*f_b_p_rec(t_pieces_cst pieces, t_board_cst board, unsigned char piece_idx, t_board **best){	t_ushort	x;	t_ushort	y;	t_board			*best_board;	t_board			*tmp_board;	best_board = NULL;	y = 0;	int k = 0;	while (y < board->size && ((*best) == NULL || (*best)->area[2] >= y))	{		x = 0;		while (x < board->size && ((*best) == NULL || (*best)->area[2] >= x))		{			tmp_board = place_piece(pieces->tab[piece_idx], board, x, y, piece_idx);			if (tmp_board != NULL)			{				if (get_best_board(tmp_board, *best) != tmp_board)					free_board(tmp_board);				else				{					if (piece_idx + 1 < pieces->size)						best_board = choose_best_board(f_b_p_rec(pieces, tmp_board, piece_idx + 1, best), best_board);					else					{						best_board = choose_best_board(tmp_board, best_board);						*best = best_board;					}				}			}			x++;		}		y++;	}	return (best_board);}int         find_best_placement(t_pieces_cst pieces){	t_board	*best_board;	best_board = NULL;	f_b_p_rec(pieces, create_board(get_pieces_size(pieces)), 0, &best_board);	print_board(best_board);	return (0);}